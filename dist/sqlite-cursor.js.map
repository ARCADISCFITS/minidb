{"version":3,"sources":["../src/sqlite-cursor.js"],"names":["SQLiteCursor","constructor","connection","rawCursor","_connection","_rawCursor","_finished","parseValues","columns","values","parsedValues","i","length","name","hasRows","next","Promise","resolve","reject","err","finished","index","close"],"mappings":";;;;;;;;AAAe,MAAMA,YAAN,CAAmB;AAChCC,cAAYC,UAAZ,EAAwBC,SAAxB,EAAmC;AACjC,SAAKC,WAAL,GAAmBF,UAAnB;AACA,SAAKG,UAAL,GAAkBF,SAAlB;AACA,SAAKG,SAAL,GAAiB,KAAjB;AACD;;AAED,MAAIJ,UAAJ,GAAiB;AACf,WAAO,KAAKE,WAAZ;AACD;;AAEDG,cAAYC,OAAZ,EAAqBC,MAArB,EAA6B;AAC3B,QAAIC,eAAe,IAAnB;;AAEA,QAAID,MAAJ,EAAY;AACVC,qBAAe,EAAf;;AAEA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,QAAQI,MAA5B,EAAoC,EAAED,CAAtC,EAAyC;AACvCD,qBAAaF,QAAQG,CAAR,EAAWE,IAAxB,IAAgCJ,OAAOE,CAAP,CAAhC;AACD;AACF;;AAED,WAAOD,YAAP;AACD;;AAED,MAAII,OAAJ,GAAc;AACZ,WAAO,CAAC,KAAKR,SAAb;AACD;;AAEKS,MAAN,GAAa;AAAA;;AAAA;AACX,aAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,cAAKb,UAAL,CAAgBU,IAAhB,CAAqB,UAACI,GAAD,EAAMC,QAAN,EAAgBZ,OAAhB,EAAyBC,MAAzB,EAAiCY,KAAjC,EAA2C;AAC9D,gBAAKf,SAAL,GAAiBc,QAAjB;;AAEA,cAAID,GAAJ,EAAS;AACP,mBAAOD,OAAOC,GAAP,CAAP;AACD,WAFD,MAEO,IAAIC,QAAJ,EAAc;AACnB,mBAAOH,QAAQ,IAAR,CAAP;AACD;;AAED,iBAAOA,QAAQ,EAACT,SAASA,OAAV;AACCC,oBAAQD,WAAW,MAAKD,WAAL,CAAiBC,OAAjB,EAA0BC,MAA1B,CADpB;AAECY,mBAAOA,KAFR,EAAR,CAAP;AAGD,SAZD;AAaD,OAdM,CAAP;AADW;AAgBZ;;AAEKC,OAAN,GAAc;AAAA;;AAAA;AACZ;AACA,aAAO,CAAC,OAAKjB,UAAL,CAAgBe,QAAxB,EAAkC;AAChC,cAAM,OAAKL,IAAL,EAAN;AACD;AAJW;AAKb;AApD+B;kBAAbf,Y","file":"sqlite-cursor.js","sourcesContent":["export default class SQLiteCursor {\n  constructor(connection, rawCursor) {\n    this._connection = connection;\n    this._rawCursor = rawCursor;\n    this._finished = false;\n  }\n\n  get connection() {\n    return this._connection;\n  }\n\n  parseValues(columns, values) {\n    let parsedValues = null;\n\n    if (values) {\n      parsedValues = {};\n\n      for (let i = 0; i < columns.length; ++i) {\n        parsedValues[columns[i].name] = values[i];\n      }\n    }\n\n    return parsedValues;\n  }\n\n  get hasRows() {\n    return !this._finished;\n  }\n\n  async next() {\n    return new Promise((resolve, reject) => {\n      this._rawCursor.next((err, finished, columns, values, index) => {\n        this._finished = finished;\n\n        if (err) {\n          return reject(err);\n        } else if (finished) {\n          return resolve(null);\n        }\n\n        return resolve({columns: columns,\n                        values: columns && this.parseValues(columns, values),\n                        index: index});\n      });\n    });\n  }\n\n  async close() {\n    // exhaust the cursor to completion\n    while (!this._rawCursor.finished) {\n      await this.next();\n    }\n  }\n}\n"]}