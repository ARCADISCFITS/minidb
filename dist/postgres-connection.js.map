{"version":3,"sources":["../src/postgres-connection.js"],"names":[],"mappings":";;;;;;;;;;;;;8BASA,WAAuB,UAAvB,EAAmC;AACjC,QAAI,OAAO,MAAM,UAAN,CAAX;;AAEA,QAAI,QAAQ,IAAZ,EAAkB;AAChB,YAAM,SAAS;AACb,YAAI,UADS;AAEb,aAAK,EAFQ;AAGb,2BAAmB,QAAQ,iBAHd;AAIb,4BAAoB,QAAQ;AAJf,OAAf;;AAOA,aAAO,MAAM,UAAN,IAAoB,iBAAG,UAAH,CAAc,MAAd,CAA3B;AACD;;AAED,WAAO,uBAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,WAAK,OAAL,CAAa,UAAS,GAAT,EAAc,MAAd,EAAsB;AACjC,YAAI,GAAJ,EAAS;AACP,iBAAO,OAAO,GAAP,CAAP;AACD;;;AAGD,cAAM,SAAS;AACb,qBAAW,MADE;;AAGb,eAHa,mBAGL;AACN,kBAAM,SAAS,OAAO,KAAP,CAAa,KAAb,CAAmB,MAAnB,EAA2B,SAA3B,CAAf;;AAEA,mBAAO;AACC,kBADD,kBACQ;AAAA;AACX,yBAAO,uBAAY,UAAC,GAAD,EAAM,GAAN,EAAc;AAC/B,2BAAO,IAAP,CAAY,UAAS,GAAT,EAAc,QAAd,EAAwB,OAAxB,EAAiC,MAAjC,EAAyC,KAAzC,EAAgD;AAC1D,0BAAI,GAAJ,EAAS;AACP,+BAAO,IAAI,GAAJ,CAAP;AACD;;AAED,6BAAO,IAAI,EAAC,SAAS,OAAV,EAAmB,QAAQ,MAA3B,EAAJ,CAAP;AACD,qBAND;AAOD,mBARM,CAAP;AADW;AAUZ,eAXI;AAaC,mBAbD,mBAaS;AAAA;;AAAA;;AAEZ,yBAAO,CAAC,OAAO,QAAP,EAAR,EAA2B;AACzB,wBAAI;AACF,4BAAM,MAAK,IAAL,EAAN;AACD,qBAFD,CAEE,OAAO,EAAP,EAAW;AACX,8BAAQ,IAAR,CAAa,gCAAb,EAA+C,EAA/C;AACD;AACF;AARW;AASb;AAtBI,aAAP;AAwBD,WA9BY;AAgCP,cAhCO,kBAgCA;AAAA;AACX,mBAAK,OAAL,CAAa,MAAb;AADW;AAEZ;AAlCY,SAAf;;AAqCA,eAAO,QAAQ,MAAR,CAAP;AACD,OA5CD;AA6CD,KA9CM,CAAP;AA+CD,G;;kBA7Dc,O;;;;;AATf;;;;AACA;;;;;;;;AAEA,MAAM,QAAQ,EAAd;;AAqEA,QAAQ,QAAR,GAAmB,YAAW;AAC5B,OAAK,MAAM,UAAX,IAAyB,OAAO,IAAP,CAAY,KAAZ,CAAzB,EAA6C;AAC3C,UAAM,OAAO,MAAM,UAAN,CAAb;;AAEA,QAAI,IAAJ,EAAU;AACR,WAAK,KAAL,CAAW,MAAM;AACf,aAAK,aAAL;AACD,OAFD;AAGD;AACF;AACF,CAVD;;AAYA,QAAQ,iBAAR,GAA4B,IAA5B;AACA,QAAQ,kBAAR,GAA6B,IAA7B;;kBAEe,O","file":"postgres-connection.js","sourcesContent":["import pg from 'minipg';\nimport Promise from 'bluebird';\n\nconst pools = {};\n\n// Wrap a single connection w/ a query method in an async function.\n// This is used when we need to execute multiple successive queries and make sure\n// they're executed on the *same* connection and not separate connections\n// from the connection pool.\nasync function connect(connection) {\n  let pool = pools[connection];\n\n  if (pool == null) {\n    const params = {\n      db: connection,\n      max: 25,\n      idleTimeoutMillis: connect.idleTimeoutMillis,\n      reapIntervalMillis: connect.reapIntervalMillis\n    };\n\n    pool = pools[connection] = pg.createPool(params);\n  }\n\n  return new Promise((resolve, reject) => {\n    pool.acquire(function(err, client) {\n      if (err) {\n        return reject(err);\n      }\n\n      // return a little object with a query method and a done method\n      const result = {\n        rawClient: client,\n\n        query() {\n          const cursor = client.query.apply(client, arguments);\n\n          return {\n            async next() {\n              return new Promise((res, rej) => {\n                cursor.next(function(err, finished, columns, values, index) {\n                  if (err) {\n                    return rej(err);\n                  }\n\n                  return res({columns: columns, values: values});\n                });\n              });\n            },\n\n            async close() {\n              // exhaust the cursor to completion\n              while (!cursor.finished()) {\n                try {\n                  await this.next();\n                } catch (ex) {\n                  console.warn('exception while closing cursor', ex);\n                }\n              }\n            }\n          };\n        },\n\n        async done() {\n          pool.release(client);\n        }\n      };\n\n      return resolve(result);\n    });\n  });\n}\n\nconnect.shutdown = function() {\n  for (const connection of Object.keys(pools)) {\n    const pool = pools[connection];\n\n    if (pool) {\n      pool.drain(() => {\n        pool.destroyAllNow();\n      });\n    }\n  }\n};\n\nconnect.idleTimeoutMillis = null;\nconnect.reapIntervalMillis = null;\n\nexport default connect;\n"]}