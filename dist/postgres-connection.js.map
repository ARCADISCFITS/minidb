{"version":3,"sources":["../src/postgres-connection.js"],"names":[],"mappings":";;;;;;;;;;;;;8BASA,WAAuB,UAAvB,EAAmC;AACjC,QAAI,OAAO,MAAM,UAAN,CAAP,CAD6B;;AAGjC,QAAI,QAAQ,IAAR,EAAc;AAChB,YAAM,SAAS;AACb,YAAI,UAAJ;AACA,aAAK,EAAL;AACA,2BAAmB,QAAQ,iBAAR;AACnB,4BAAoB,QAAQ,kBAAR;OAJhB,CADU;;AAQhB,aAAO,MAAM,UAAN,IAAoB,iBAAG,UAAH,CAAc,MAAd,CAApB,CARS;KAAlB;;AAWA,WAAO,uBAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,WAAK,OAAL,CAAa,UAAS,GAAT,EAAc,MAAd,EAAsB;AACjC,YAAI,GAAJ,EAAS;AACP,iBAAO,OAAO,GAAP,CAAP,CADO;SAAT;;;AADiC,cAM3B,SAAS;AACb,qBAAW,MAAX;;AAEA,kCAAQ;AACN,kBAAM,SAAS,OAAO,KAAP,CAAa,KAAb,CAAmB,MAAnB,EAA2B,SAA3B,CAAT,CADA;;AAGN,mBAAO;AACC,oCAAO;;AACX,yBAAO,uBAAY,UAAC,GAAD,EAAM,GAAN,EAAc;AAC/B,2BAAO,IAAP,CAAY,UAAS,GAAT,EAAc,QAAd,EAAwB,OAAxB,EAAiC,MAAjC,EAAyC,KAAzC,EAAgD;AAC1D,0BAAI,GAAJ,EAAS;AACP,+BAAO,IAAI,GAAJ,CAAP,CADO;uBAAT;;AAIA,6BAAO,IAAI,EAAC,SAAS,OAAT,EAAkB,QAAQ,MAAR,EAAvB,CAAP,CAL0D;qBAAhD,CAAZ,CAD+B;mBAAd,CAAnB;qBADW;eADR;AAaC,sCAAQ;;;;;AAEZ,yBAAO,CAAC,OAAO,QAAP,EAAD,EAAoB;AACzB,wBAAI;AACF,4BAAM,MAAK,IAAL,EAAN,CADE;qBAAJ,CAEE,OAAO,EAAP,EAAW;AACX,8BAAQ,IAAR,CAAa,gCAAb,EAA+C,EAA/C,EADW;qBAAX;mBAHJ;qBAFY;eAbT;aAAP,CAHM;WAHK;AAgCP,gCAAO;;AACX,mBAAK,OAAL,CAAa,MAAb;iBADW;WAhCA;SAAT,CAN2B;;AA2CjC,eAAO,QAAQ,MAAR,CAAP,CA3CiC;OAAtB,CAAb,CADsC;KAArB,CAAnB,CAdiC;GAAnC;;kBAAe;;;;;AATf;;;;AACA;;;;;;;;AAEA,MAAM,QAAQ,EAAR;;AAqEN,QAAQ,iBAAR,GAA4B,IAA5B;AACA,QAAQ,kBAAR,GAA6B,IAA7B;;kBAEe","file":"postgres-connection.js","sourcesContent":["import pg from 'minipg';\nimport Promise from 'bluebird';\n\nconst pools = {};\n\n// Wrap a single connection w/ a query method in an async function.\n// This is used when we need to execute multiple successive queries and make sure\n// they're executed on the *same* connection and not separate connections\n// from the connection pool.\nasync function connect(connection) {\n  let pool = pools[connection];\n\n  if (pool == null) {\n    const params = {\n      db: connection,\n      max: 25,\n      idleTimeoutMillis: connect.idleTimeoutMillis,\n      reapIntervalMillis: connect.reapIntervalMillis\n    };\n\n    pool = pools[connection] = pg.createPool(params);\n  }\n\n  return new Promise((resolve, reject) => {\n    pool.acquire(function(err, client) {\n      if (err) {\n        return reject(err);\n      }\n\n      // return a little object with a query method and a done method\n      const result = {\n        rawClient: client,\n\n        query() {\n          const cursor = client.query.apply(client, arguments);\n\n          return {\n            async next() {\n              return new Promise((res, rej) => {\n                cursor.next(function(err, finished, columns, values, index) {\n                  if (err) {\n                    return rej(err);\n                  }\n\n                  return res({columns: columns, values: values});\n                });\n              });\n            },\n\n            async close() {\n              // exhaust the cursor to completion\n              while (!cursor.finished()) {\n                try {\n                  await this.next();\n                } catch (ex) {\n                  console.warn('exception while closing cursor', ex);\n                }\n              }\n            }\n          };\n        },\n\n        async done() {\n          pool.release(client);\n        }\n      };\n\n      return resolve(result);\n    });\n  });\n}\n\nconnect.idleTimeoutMillis = null;\nconnect.reapIntervalMillis = null;\n\nexport default connect;\n"]}