{"version":3,"sources":["../src/postgres-connection.js"],"names":[],"mappings":";;;;;;;;;;;;;8BAQA,WAAuB,UAAvB,EAAmC;AACjC,QAAI,OAAO,MAAM,UAAN,CAAX;;AAEA,QAAI,QAAQ,IAAZ,EAAkB;AAChB,YAAM,SAAS;AACb,YAAI,UADS;AAEb,aAAK,EAFQ;AAGb,2BAAmB,QAAQ,iBAHd;AAIb,4BAAoB,QAAQ;AAJf,OAAf;;AAOA,aAAO,MAAM,UAAN,IAAoB,wBAAW,MAAX,CAA3B;AACD;;AAED,WAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,WAAK,OAAL,CAAa,UAAC,GAAD,EAAM,MAAN,EAAiB;AAC5B,YAAI,GAAJ,EAAS;AACP,iBAAO,GAAP;AACA;AACD;;;AAGD,cAAM,SAAS;AACb,qBAAW,MADE;;AAGb,eAHa,mBAGL;AACN,kBAAM,SAAS,OAAO,KAAP,CAAa,KAAb,CAAmB,MAAnB,EAA2B,SAA3B,CAAf;;AAEA,mBAAO;AACC,kBADD,kBACQ;AAAA;AACX,yBAAO,IAAI,OAAJ,CAAY,UAAC,GAAD,EAAM,GAAN,EAAc;AAC/B,2BAAO,IAAP,CAAY,UAAC,GAAD,EAAM,QAAN,EAAgB,OAAhB,EAAyB,MAAzB,EAAiC,KAAjC,EAA2C;AACrD,0BAAI,GAAJ,EAAS;AACP,+BAAO,IAAI,GAAJ,CAAP;AACD;;AAED,6BAAO,IAAI,EAAC,SAAS,OAAV,EAAmB,QAAQ,MAA3B,EAAJ,CAAP;AACD,qBAND;AAOD,mBARM,CAAP;AADW;AAUZ,eAXI;AAaC,mBAbD,mBAaS;AAAA;;AAAA;;AAEZ,yBAAO,CAAC,OAAO,QAAf,EAAyB;AACvB,wBAAI;AACF,4BAAM,MAAK,IAAL,EAAN;AACD,qBAFD,CAEE,OAAO,EAAP,EAAW;AACX,8BAAQ,IAAR,CAAa,gCAAb,EAA+C,EAA/C;AACD;AACF;AARW;AASb;AAtBI,aAAP;AAwBD,WA9BY;AAgCP,cAhCO,kBAgCA;AAAA;AACX,mBAAK,OAAL,CAAa,MAAb;AADW;AAEZ;AAlCY,SAAf;;AAqCA,gBAAQ,MAAR;AACD,OA7CD;AA8CD,KA/CM,CAAP;AAgDD,G;;kBA9Dc,O;;;;;AARf;;;;AAEA,MAAM,QAAQ,EAAd;;AAsEA,QAAQ,QAAR,GAAmB,MAAM;AACvB,OAAK,MAAM,UAAX,IAAyB,OAAO,IAAP,CAAY,KAAZ,CAAzB,EAA6C;AAC3C,UAAM,OAAO,MAAM,UAAN,CAAb;;AAEA,QAAI,IAAJ,EAAU;AACR,WAAK,KAAL,CAAW,MAAM;AACf,aAAK,aAAL;AACD,OAFD;AAGD;AACF;AACF,CAVD;;AAYA,QAAQ,iBAAR,GAA4B,IAA5B;AACA,QAAQ,kBAAR,GAA6B,IAA7B;;kBAEe,O","file":"postgres-connection.js","sourcesContent":["import { createPool } from 'minipg';\n\nconst pools = {};\n\n// Wrap a single connection w/ a query method in an async function.\n// This is used when we need to execute multiple successive queries and make sure\n// they're executed on the *same* connection and not separate connections\n// from the connection pool.\nasync function connect(connection) {\n  let pool = pools[connection];\n\n  if (pool == null) {\n    const params = {\n      db: connection,\n      max: 25,\n      idleTimeoutMillis: connect.idleTimeoutMillis,\n      reapIntervalMillis: connect.reapIntervalMillis\n    };\n\n    pool = pools[connection] = createPool(params);\n  }\n\n  return new Promise((resolve, reject) => {\n    pool.acquire((err, client) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      // return a little object with a query method and a done method\n      const result = {\n        rawClient: client,\n\n        query() {\n          const cursor = client.query.apply(client, arguments);\n\n          return {\n            async next() {\n              return new Promise((res, rej) => {\n                cursor.next((err, finished, columns, values, index) => {\n                  if (err) {\n                    return rej(err);\n                  }\n\n                  return res({columns: columns, values: values});\n                });\n              });\n            },\n\n            async close() {\n              // exhaust the cursor to completion\n              while (!cursor.finished) {\n                try {\n                  await this.next();\n                } catch (ex) {\n                  console.warn('exception while closing cursor', ex);\n                }\n              }\n            }\n          };\n        },\n\n        async done() {\n          pool.release(client);\n        }\n      };\n\n      resolve(result);\n    });\n  });\n}\n\nconnect.shutdown = () => {\n  for (const connection of Object.keys(pools)) {\n    const pool = pools[connection];\n\n    if (pool) {\n      pool.drain(() => {\n        pool.destroyAllNow();\n      });\n    }\n  }\n};\n\nconnect.idleTimeoutMillis = null;\nconnect.reapIntervalMillis = null;\n\nexport default connect;\n"]}