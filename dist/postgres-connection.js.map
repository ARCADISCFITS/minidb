{"version":3,"sources":["../src/postgres-connection.js"],"names":[],"mappings":";;;;;;AAAA;;AACA;;;;;;;;AAEA,MAAM,QAAQ,EAAd;;;;;;AAMe,MAAM,kBAAN,CAAyB;AACtC,cAAY,IAAZ,EAAkB,SAAlB,EAA6B;AAC3B,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,SAAL,GAAiB,SAAjB;AACD;;AAED,SAAO,IAAP,CAAY,gBAAZ,EAA8B;AAC5B,QAAI,OAAO,MAAM,gBAAN,CAAX;;AAEA,QAAI,QAAQ,IAAZ,EAAkB;AAChB,YAAM,SAAS;AACb,YAAI,gBADS;AAEb,aAAK,EAFQ;AAGb,2BAAmB,mBAAmB,iBAHzB;AAIb,4BAAoB,mBAAmB;AAJ1B,OAAf;;AAOA,aAAO,MAAM,gBAAN,IAA0B,wBAAW,MAAX,CAAjC;AACD;;AAED,WAAO,IAAP;AACD;;AAED,UAAe;AACb,WAAO,6BAAmB,IAAnB,EAAyB,KAAK,SAAL,CAAe,KAAf,CAAqB,YAArB,CAAzB,CAAP;AACD;;AAED,UAAQ;AACN,SAAK,IAAL,CAAU,OAAV,CAAkB,KAAK,SAAvB;AACA,SAAK,SAAL,GAAiB,IAAjB;AACD;;AAED,SAAa,OAAb,CAAqB,gBAArB,EAAuC;AAAA;AACrC,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,cAAM,OAAO,mBAAmB,IAAnB,CAAwB,gBAAxB,CAAb;;AAEA,aAAK,OAAL,CAAa,UAAC,GAAD,EAAM,MAAN,EAAiB;AAC5B,cAAI,GAAJ,EAAS;AACP,mBAAO,OAAO,GAAP,CAAP;AACD;;AAED,iBAAO,QAAQ,IAAI,kBAAJ,CAAuB,IAAvB,EAA6B,MAA7B,CAAR,CAAP;AACD,SAND;AAOD,OAVM,CAAP;AADqC;AAYtC;;AAED,SAAO,QAAP,GAAkB;AAChB,SAAK,MAAM,UAAX,IAAyB,OAAO,IAAP,CAAY,KAAZ,CAAzB,EAA6C;AAC3C,YAAM,OAAO,MAAM,UAAN,CAAb;;AAEA,UAAI,IAAJ,EAAU;AACR,aAAK,KAAL,CAAW,MAAM;AACf,eAAK,aAAL;AACD,SAFD;AAGD;AACF;AACF;AAxDqC;;kBAAnB,kB;AA2DrB,mBAAmB,iBAAnB,GAAuC,IAAvC;AACA,mBAAmB,kBAAnB,GAAwC,IAAxC","file":"postgres-connection.js","sourcesContent":["import { createPool } from 'minipg';\nimport PostgresCursor from './postgres-cursor';\n\nconst POOLS = {};\n\n// Wrap a single connection w/ a query method in an async function.\n// This is used when we need to execute multiple successive queries and make sure\n// they're executed on the *same* connection and not separate connections\n// from the connection pool.\nexport default class PostgresConnection {\n  constructor(pool, rawClient) {\n    this.pool = pool;\n    this.rawClient = rawClient;\n  }\n\n  static pool(connectionString) {\n    let pool = POOLS[connectionString];\n\n    if (pool == null) {\n      const params = {\n        db: connectionString,\n        max: 25,\n        idleTimeoutMillis: PostgresConnection.idleTimeoutMillis,\n        reapIntervalMillis: PostgresConnection.reapIntervalMillis\n      };\n\n      pool = POOLS[connectionString] = createPool(params);\n    }\n\n    return pool;\n  }\n\n  query(...args) {\n    return new PostgresCursor(this, this.rawClient.query(...args));\n  }\n\n  close() {\n    this.pool.release(this.rawClient);\n    this.rawClient = null;\n  }\n\n  static async connect(connectionString) {\n    return new Promise((resolve, reject) => {\n      const pool = PostgresConnection.pool(connectionString);\n\n      pool.acquire((err, client) => {\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(new PostgresConnection(pool, client));\n      });\n    });\n  }\n\n  static shutdown() {\n    for (const connection of Object.keys(POOLS)) {\n      const pool = POOLS[connection];\n\n      if (pool) {\n        pool.drain(() => {\n          pool.destroyAllNow();\n        });\n      }\n    }\n  }\n}\n\nPostgresConnection.idleTimeoutMillis = null;\nPostgresConnection.reapIntervalMillis = null;\n"]}