{"version":3,"sources":["../src/postgres.js"],"names":[],"mappings":"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","file":"postgres.js","sourcesContent":["import Promise from 'bluebird';\nimport connection from './postgres-connection';\nimport pg from 'pg';\nimport minipg from 'minipg';\nimport pgformat from 'pg-format';\nimport {format} from 'util';\nimport esc from './esc';\nimport Database from './database';\n\n// Parse bigints as `Number` objects. If a caller *really* knows their\n// number cannot fit in a JS Number, it can be casted to `text` in\n// the query and parsed manually. Without this, dead simple COUNT(*)\n// queries are returned as text and it makes doing simple things hard.\npg.types.setTypeParser(20, function(val) {\n  return val == null ? null : parseInt(val, 10);\n});\n\nexport default class Postgres extends Database {\n  constructor(options) {\n    super(options);\n\n    this.client = options.client;\n  }\n\n  ident(value) {\n    return esc(value, '\"');\n  }\n\n  static setNoticeProcessor(processor) {\n    minipg.Client.defaultNoticeProcessor = processor;\n  }\n\n  static async connect(db) {\n    return await connection(db);\n  }\n\n  static shutdown() {\n    connection.shutdown();\n  }\n\n  get dialect() {\n    return 'postgresql';\n  }\n\n  async each(sql, params, callback) {\n    const self = this;\n\n    const exec = function(client) {\n      return new Promise((resolve, reject) => {\n        client.rawClient.query(sql).each(function(err, finished, columns, values, index) {\n          if (err) {\n            return reject(err);\n          } else if (finished) {\n            return resolve(null);\n          }\n\n          if (!callback) {\n            return null;\n          }\n\n          let parsedValues = null;\n\n          if (values) {\n            ++index;\n\n            parsedValues = {};\n\n            for (let i = 0; i < columns.length; ++i) {\n              let value = values[i];\n\n              if (value != null) {\n                value = pg.types.getTypeParser(columns[i].type)(value);\n              }\n\n              parsedValues[columns[i].name] = value;\n            }\n          }\n\n          return callback(columns, parsedValues, index);\n        });\n      });\n    };\n\n    let close = false;\n    let client = this.client;\n\n    if (client == null) {\n      close = true;\n      client = await Postgres.connect(this.options.db);\n    }\n\n    try {\n      await exec(client);\n    } catch (ex) {\n      if (self.verbose) {\n        console.error('ERROR', ex);\n      }\n\n      if (close) {\n        await client.done();\n      }\n\n      throw ex;\n    }\n\n    if (close) {\n      await client.done();\n    }\n  }\n\n  async close() {\n    if (this.client) {\n      await this.client.done();\n\n      this.client = null;\n    }\n  }\n\n  async execute(sql, params) {\n    return await this.each(sql, [], null);\n  }\n\n  beginTransaction() {\n    if (this.client == null) {\n      throw new Error('client is null when beginning a transaction');\n    }\n\n    return this.execute('BEGIN TRANSACTION;');\n  }\n\n  commit() {\n    if (this.client == null) {\n      throw new Error('client is null when committing a transaction');\n    }\n\n    return this.execute('COMMIT TRANSACTION;');\n  }\n\n  rollback() {\n    if (this.client == null) {\n      throw new Error('client is null when rolling back a transaction');\n    }\n\n    return this.execute('ROLLBACK TRANSACTION;');\n  }\n\n  async transaction(block) {\n    // get a connection from the pool and make sure it gets used throughout the\n    // transaction block.\n    const client = await Postgres.connect(this.options.db);\n\n    const db = new Postgres(Object.assign({}, this.options, {client: client}));\n\n    await db.beginTransaction();\n\n    try {\n      await block(db);\n      await db.commit();\n      await db.close();\n    } catch (ex) {\n      await db.rollback();\n      throw ex;\n    }\n  }\n\n  buildWhere(where) {\n    const clause = [];\n\n    if (where) {\n      for (const key of Object.keys(where)) {\n        clause.push(pgformat('%I = %L', key, where[key]));\n      }\n    }\n\n    return [clause, []];\n  }\n\n  buildInsert(attributes) {\n    const names = [];\n    const values = [];\n    const placeholders = [];\n\n    // Use the literal values instead of placeholders  because parameterized\n    // queries require prepared statements. Prepared statements are stateful\n    // and impose requirements on the connection that are incompatible with\n    // pgbouncer.\n    for (const key of Object.keys(attributes)) {\n      names.push(pgformat('%I', key));\n\n      const value = attributes[key];\n\n      if (Array.isArray(value)) {\n        placeholders.push(pgformat('ARRAY[%L]', value));\n      } else {\n        placeholders.push(pgformat('%L', value));\n      }\n    }\n\n    return [names, placeholders, values];\n  }\n\n  buildUpdate(attributes) {\n    const sets = [];\n    const values = [];\n\n    for (const key of Object.keys(attributes)) {\n      const value = attributes[key];\n\n      if (Array.isArray(value)) {\n        sets.push(pgformat('%I = ARRAY[%L]', key, value));\n      } else {\n        sets.push(pgformat('%I = %L', key, value));\n      }\n    }\n\n    return [sets, values];\n  }\n\n  async insert(table, attributes, options) {\n    if (options == null || options.pk == null) {\n      throw new Error('pk is required');\n    }\n\n    const [names, placeholders, values] = this.buildInsert(attributes);\n\n    const sql = format('INSERT INTO %s (%s)\\nVALUES (%s) RETURNING %s;',\n                       table,\n                       names.join(', '),\n                       placeholders.join(', '),\n                       options.pk);\n\n    const result = await this.all(sql, values);\n\n    return +result[0].id;\n  }\n\n  toDatabase(value, column) {\n    if (value == null) {\n      return null;\n    }\n\n    switch (column.type) {\n      case 'datetime':\n        return value.toISOString();\n\n      default:\n        return super.toDatabase(value, column);\n    }\n  }\n\n  fromDatabase(value, column) {\n    if (value == null) {\n      return null;\n    }\n\n    switch (column.type) {\n      case 'datetime':\n        return new Date(value);\n\n      default:\n        return super.fromDatabase(value, column);\n    }\n  }\n}\n"]}