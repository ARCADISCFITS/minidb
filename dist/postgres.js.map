{"version":3,"sources":["../src/postgres.js"],"names":[],"mappings":"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","file":"postgres.js","sourcesContent":["import PostgresConnection from './postgres-connection';\nimport pg from 'pg';\nimport { Client } from 'minipg';\nimport pgformat from 'pg-format';\nimport { format } from 'util';\nimport esc from './esc';\nimport Database from './database';\n\n// Parse bigints as `Number` objects. If a caller *really* knows their\n// number cannot fit in a JS Number, it can be casted to `text` in\n// the query and parsed manually. Without this, dead simple COUNT(*)\n// queries are returned as text and it makes doing simple things hard.\npg.types.setTypeParser(20, (val) => {\n  return val == null ? null : parseInt(val, 10);\n});\n\nexport default class Postgres extends Database {\n  constructor(options) {\n    super(options);\n\n    this.client = options.client;\n  }\n\n  ident(value) {\n    return esc(value, '\"');\n  }\n\n  static setNoticeProcessor(processor) {\n    Client.defaultNoticeProcessor = processor;\n  }\n\n  static async connect(db) {\n    return await PostgresConnection.connect(db);\n  }\n\n  static shutdown() {\n    PostgresConnection.shutdown();\n  }\n\n  get dialect() {\n    return 'postgresql';\n  }\n\n  async each(sql, params, callback) {\n    this.log(sql);\n\n    let close = false;\n    let client = this.client;\n    let cursor = null;\n\n    if (client == null) {\n      close = true;\n      client = await Postgres.connect(this.options.db);\n    }\n\n    try {\n      cursor = client.query(sql);\n\n      while (cursor.hasRows) {\n        const result = await cursor.next();\n\n        if (result && callback) {\n          /* eslint-disable callback-return */\n          await callback(result.columns, result.values, result.index);\n          /* eslint-enable callback-return */\n        }\n      }\n    } catch (ex) {\n      if (this.verbose) {\n        console.error('ERROR', ex);\n      }\n\n      throw ex;\n    } finally {\n      if (cursor) {\n        try {\n          await cursor.close();\n        } catch (err) {\n          // Closing the cursor on a connection where there was a previous error rethrows the same error\n          // This is because pumping the cursor to completion ends up carrying the original error to\n          // the end. This is desired behavior, we just have to swallow any potential errors here.\n        }\n      }\n\n      if (close) {\n        await client.close();\n      }\n    }\n  }\n\n  async close() {\n    if (this.client) {\n      await this.client.close();\n\n      this.client = null;\n    }\n  }\n\n  async execute(sql, params) {\n    let columns = null;\n    const rows = [];\n\n    await this.each(sql, [], async (cols, values, index) => {\n      if (columns == null) {\n        columns = cols;\n      }\n\n      if (values) {\n        rows.push(values);\n      }\n    });\n\n    return { rows: rows, columns: columns };\n  }\n\n  async query(sql, params) {\n    this.log(sql);\n\n    let client = this.client;\n\n    if (client == null) {\n      client = await Postgres.connect(this.options.db);\n    }\n\n    return client.query(sql, params);\n  }\n\n  beginTransaction() {\n    if (this.client == null) {\n      throw new Error('client is null when beginning a transaction');\n    }\n\n    return this.execute('BEGIN TRANSACTION;');\n  }\n\n  commit() {\n    if (this.client == null) {\n      throw new Error('client is null when committing a transaction');\n    }\n\n    return this.execute('COMMIT TRANSACTION;');\n  }\n\n  rollback() {\n    if (this.client == null) {\n      throw new Error('client is null when rolling back a transaction');\n    }\n\n    return this.execute('ROLLBACK TRANSACTION;');\n  }\n\n  async transaction(block) {\n    // get a connection from the pool and make sure it gets used throughout the\n    // transaction block.\n    const client = await Postgres.connect(this.options.db);\n\n    const db = new Postgres(Object.assign({}, this.options, {client: client}));\n\n    await db.beginTransaction();\n\n    try {\n      await block(db);\n      await db.commit();\n    } catch (ex) {\n      try {\n        await db.rollback();\n      } catch (rollbackError) {\n        await db.close();\n        throw rollbackError;\n      }\n\n      throw ex;\n    } finally {\n      await db.close();\n    }\n  }\n\n  static transaction(options, block) {\n    return new Postgres(options).transaction(block);\n  }\n\n  static async using(options, block) {\n    const connection = await Postgres.connect(options.db);\n\n    const db = new Postgres(Object.assign({}, options, {client: connection}));\n\n    try {\n      await block(db);\n    } finally {\n      await connection.close();\n    }\n  }\n\n  arrayFormatString(array) {\n    if (Number.isInteger(array[0])) {\n      return 'ARRAY[%L]::bigint[]';\n    } else if (typeof array[0] === 'number') {\n      return 'ARRAY[%L]::double precision[]';\n    }\n\n    return 'ARRAY[%L]';\n  }\n\n  buildWhere(where) {\n    const clause = [];\n\n    if (where) {\n      for (const key of Object.keys(where)) {\n        if (Array.isArray(where[key])) {\n          clause.push(pgformat('%I = ANY (' + this.arrayFormatString(where[key]) + ')', key, where[key]));\n        } else {\n          clause.push(pgformat('%I = %L', key, where[key]));\n        }\n      }\n    }\n\n    return [ clause, [] ];\n  }\n\n  buildInsert(attributes, includeNames = true) {\n    const names = [];\n    const values = [];\n    const placeholders = [];\n\n    // Use the literal values instead of placeholders  because parameterized\n    // queries require prepared statements. Prepared statements are stateful\n    // and impose requirements on the connection that are incompatible with\n    // pgbouncer.\n    for (const key of Object.keys(attributes)) {\n      if (includeNames) {\n        names.push(pgformat('%I', key));\n      }\n\n      const value = attributes[key];\n\n      if (Array.isArray(value)) {\n        placeholders.push(pgformat('ARRAY[%L]', value));\n      } else if (value && value.raw) {\n        placeholders.push(pgformat('%s', value.raw));\n      } else {\n        placeholders.push(pgformat('%L', value));\n      }\n    }\n\n    return [ names, placeholders, values ];\n  }\n\n  buildUpdate(attributes) {\n    const sets = [];\n    const values = [];\n\n    for (const key of Object.keys(attributes)) {\n      const value = attributes[key];\n\n      if (Array.isArray(value)) {\n        sets.push(pgformat('%I = ARRAY[%L]', key, value));\n      } else if (value && value.raw) {\n        sets.push(pgformat('%I = %s', value.raw));\n      } else {\n        sets.push(pgformat('%I = %L', key, value));\n      }\n    }\n\n    return [ sets, values ];\n  }\n\n  insertStatement(table, attributes, options) {\n    if (options == null || options.pk == null) {\n      throw new Error('pk is required');\n    }\n\n    const [ names, placeholders, values ] = this.buildInsert(attributes);\n\n    const returning = options && options.returnPrimaryKey === false ? '' : ' RETURNING ' + options.pk;\n\n    const sql = format('INSERT INTO %s (%s)\\nVALUES (%s)%s;',\n                       table,\n                       names.join(', '),\n                       placeholders.join(', '),\n                       returning);\n\n    return {sql, values};\n  }\n\n  insertStatements(table, arrayOfAttributes, options) {\n    const arrayOfValues = [];\n\n    let names = null;\n\n    for (const attributes of arrayOfAttributes) {\n      const insert = this.buildInsert(attributes, names == null);\n\n      if (names == null) {\n        names = insert[0];\n      }\n\n      arrayOfValues.push('(' + insert[1].join(', ') + ')');\n    }\n\n    const sql = format('INSERT INTO %s (%s)\\nVALUES %s;',\n                       table,\n                       names.join(', '),\n                       arrayOfValues.join(',\\n'));\n\n    return {sql, values: {}};\n  }\n\n  async insert(table, attributes, options) {\n    const statement = this.insertStatement(table, attributes, options);\n\n    const result = await this.all(statement.sql, statement.values);\n\n    return +result[0].id;\n  }\n\n  toDatabase(value, column) {\n    if (value == null) {\n      return null;\n    }\n\n    switch (column.type) {\n      case 'datetime':\n        return value.toISOString();\n\n      default:\n        return super.toDatabase(value, column);\n    }\n  }\n\n  fromDatabase(value, column) {\n    if (value == null) {\n      return null;\n    }\n\n    switch (column.type) {\n      case 'datetime':\n        return new Date(value);\n\n      default:\n        return super.fromDatabase(value, column);\n    }\n  }\n}\n"]}