{"version":3,"sources":["../src/postgres-cursor.js"],"names":["PostgresCursor","constructor","connection","rawCursor","_connection","_rawCursor","_finished","parseValues","columns","values","parsedValues","i","length","value","types","getTypeParser","type","name","hasRows","next","Promise","resolve","reject","err","finished","index","close"],"mappings":";;;;;;AAAA;;;;;;;;AAEe,MAAMA,cAAN,CAAqB;AAClCC,cAAYC,UAAZ,EAAwBC,SAAxB,EAAmC;AACjC,SAAKC,WAAL,GAAmBF,UAAnB;AACA,SAAKG,UAAL,GAAkBF,SAAlB;AACA,SAAKG,SAAL,GAAiB,KAAjB;AACD;;AAED,MAAIJ,UAAJ,GAAiB;AACf,WAAO,KAAKE,WAAZ;AACD;;AAEDG,cAAYC,OAAZ,EAAqBC,MAArB,EAA6B;AAC3B,QAAIC,eAAe,IAAnB;;AAEA,QAAID,MAAJ,EAAY;AACVC,qBAAe,EAAf;;AAEA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,QAAQI,MAA5B,EAAoC,EAAED,CAAtC,EAAyC;AACvC,YAAIE,QAAQJ,OAAOE,CAAP,CAAZ;;AAEA,YAAIE,SAAS,IAAb,EAAmB;AACjBA,kBAAQ,aAAGC,KAAH,CAASC,aAAT,CAAuBP,QAAQG,CAAR,EAAWK,IAAlC,EAAwCH,KAAxC,CAAR;AACD;;AAEDH,qBAAaF,QAAQG,CAAR,EAAWM,IAAxB,IAAgCJ,KAAhC;AACD;AACF;;AAED,WAAOH,YAAP;AACD;;AAED,MAAIQ,OAAJ,GAAc;AACZ,WAAO,CAAC,KAAKZ,SAAb;AACD;;AAEKa,MAAN,GAAa;AAAA;;AAAA;AACX,aAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,cAAKjB,UAAL,CAAgBc,IAAhB,CAAqB,UAACI,GAAD,EAAMC,QAAN,EAAgBhB,OAAhB,EAAyBC,MAAzB,EAAiCgB,KAAjC,EAA2C;AAC9D,gBAAKnB,SAAL,GAAiBkB,QAAjB;;AAEA,cAAID,GAAJ,EAAS;AACP,mBAAOD,OAAOC,GAAP,CAAP;AACD,WAFD,MAEO,IAAIC,QAAJ,EAAc;AACnB,mBAAOH,QAAQ,IAAR,CAAP;AACD;;AAED,iBAAOA,QAAQ,EAACb,SAASA,OAAV;AACCC,oBAAQD,WAAW,MAAKD,WAAL,CAAiBC,OAAjB,EAA0BC,MAA1B,CADpB;AAECgB,mBAAOA,KAFR,EAAR,CAAP;AAGD,SAZD;AAaD,OAdM,CAAP;AADW;AAgBZ;;AAEKC,OAAN,GAAc;AAAA;;AAAA;AACZ;AACA,aAAO,CAAC,OAAKrB,UAAL,CAAgBmB,QAAxB,EAAkC;AAChC,cAAM,OAAKL,IAAL,EAAN;AACD;AAJW;AAKb;AA1DiC;kBAAfnB,c","file":"postgres-cursor.js","sourcesContent":["import pg from 'pg';\n\nexport default class PostgresCursor {\n  constructor(connection, rawCursor) {\n    this._connection = connection;\n    this._rawCursor = rawCursor;\n    this._finished = false;\n  }\n\n  get connection() {\n    return this._connection;\n  }\n\n  parseValues(columns, values) {\n    let parsedValues = null;\n\n    if (values) {\n      parsedValues = {};\n\n      for (let i = 0; i < columns.length; ++i) {\n        let value = values[i];\n\n        if (value != null) {\n          value = pg.types.getTypeParser(columns[i].type)(value);\n        }\n\n        parsedValues[columns[i].name] = value;\n      }\n    }\n\n    return parsedValues;\n  }\n\n  get hasRows() {\n    return !this._finished;\n  }\n\n  async next() {\n    return new Promise((resolve, reject) => {\n      this._rawCursor.next((err, finished, columns, values, index) => {\n        this._finished = finished;\n\n        if (err) {\n          return reject(err);\n        } else if (finished) {\n          return resolve(null);\n        }\n\n        return resolve({columns: columns,\n                        values: columns && this.parseValues(columns, values),\n                        index: index});\n      });\n    });\n  }\n\n  async close() {\n    // exhaust the cursor to completion\n    while (!this._rawCursor.finished) {\n      await this.next();\n    }\n  }\n}\n"]}