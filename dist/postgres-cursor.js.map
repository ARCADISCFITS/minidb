{"version":3,"sources":["../src/postgres-cursor.js"],"names":[],"mappings":";;;;;;AAAA;;;;;;;;AAEe,MAAM,cAAN,CAAqB;AAClC,cAAY,UAAZ,EAAwB,SAAxB,EAAmC;AACjC,SAAK,WAAL,GAAmB,UAAnB;AACA,SAAK,UAAL,GAAkB,SAAlB;AACA,SAAK,SAAL,GAAiB,KAAjB;AACD;;AAED,MAAI,UAAJ,GAAiB;AACf,WAAO,KAAK,WAAZ;AACD;;AAED,cAAY,OAAZ,EAAqB,MAArB,EAA6B;AAC3B,QAAI,eAAe,IAAnB;;AAEA,QAAI,MAAJ,EAAY;AACV,qBAAe,EAAf;;AAEA,WAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,MAA5B,EAAoC,EAAE,CAAtC,EAAyC;AACvC,YAAI,QAAQ,OAAO,CAAP,CAAZ;;AAEA,YAAI,SAAS,IAAb,EAAmB;AACjB,kBAAQ,aAAG,KAAH,CAAS,aAAT,CAAuB,QAAQ,CAAR,EAAW,IAAlC,EAAwC,KAAxC,CAAR;AACD;;AAED,qBAAa,QAAQ,CAAR,EAAW,IAAxB,IAAgC,KAAhC;AACD;AACF;;AAED,WAAO,YAAP;AACD;;AAED,MAAI,OAAJ,GAAc;AACZ,WAAO,CAAC,KAAK,SAAb;AACD;;AAEK,MAAN,GAAa;AAAA;;AAAA;AACX,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,cAAK,UAAL,CAAgB,IAAhB,CAAqB,UAAC,GAAD,EAAM,QAAN,EAAgB,OAAhB,EAAyB,MAAzB,EAAiC,KAAjC,EAA2C;AAC9D,gBAAK,SAAL,GAAiB,QAAjB;;AAEA,cAAI,GAAJ,EAAS;AACP,mBAAO,OAAO,GAAP,CAAP;AACD,WAFD,MAEO,IAAI,QAAJ,EAAc;AACnB,mBAAO,QAAQ,IAAR,CAAP;AACD;;AAED,iBAAO,QAAQ,EAAC,SAAS,OAAV;AACC,oBAAQ,WAAW,MAAK,WAAL,CAAiB,OAAjB,EAA0B,MAA1B,CADpB;AAEC,mBAAO,KAFR,EAAR,CAAP;AAGD,SAZD;AAaD,OAdM,CAAP;AADW;AAgBZ;;AAEK,OAAN,GAAc;AAAA;;AAAA;;AAEZ,aAAO,CAAC,OAAK,UAAL,CAAgB,QAAxB,EAAkC;AAChC,cAAM,OAAK,IAAL,EAAN;AACD;AAJW;AAKb;AA1DiC;kBAAf,c","file":"postgres-cursor.js","sourcesContent":["import pg from 'pg';\n\nexport default class PostgresCursor {\n  constructor(connection, rawCursor) {\n    this._connection = connection;\n    this._rawCursor = rawCursor;\n    this._finished = false;\n  }\n\n  get connection() {\n    return this._connection;\n  }\n\n  parseValues(columns, values) {\n    let parsedValues = null;\n\n    if (values) {\n      parsedValues = {};\n\n      for (let i = 0; i < columns.length; ++i) {\n        let value = values[i];\n\n        if (value != null) {\n          value = pg.types.getTypeParser(columns[i].type)(value);\n        }\n\n        parsedValues[columns[i].name] = value;\n      }\n    }\n\n    return parsedValues;\n  }\n\n  get hasRows() {\n    return !this._finished;\n  }\n\n  async next() {\n    return new Promise((resolve, reject) => {\n      this._rawCursor.next((err, finished, columns, values, index) => {\n        this._finished = finished;\n\n        if (err) {\n          return reject(err);\n        } else if (finished) {\n          return resolve(null);\n        }\n\n        return resolve({columns: columns,\n                        values: columns && this.parseValues(columns, values),\n                        index: index});\n      });\n    });\n  }\n\n  async close() {\n    // exhaust the cursor to completion\n    while (!this._rawCursor.finished) {\n      await this.next();\n    }\n  }\n}\n"]}