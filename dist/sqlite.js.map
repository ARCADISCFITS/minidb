{"version":3,"sources":["../src/sqlite.js"],"names":["SQLite","constructor","options","client","setup","wal","execute","autoVacuum","synchronous","toUpperCase","ident","value","connect","db","shutdown","dialect","_each","sql","params","callback","log","close","cursor","index","console","query","hasRows","result","next","columns","values","ex","verbose","error","_lastInsertID","rawClient","lastInsertID","err","_execute","resultColumns","rows","push","beginTransaction","Error","commit","rollback","transaction","block","Object","assign","rollbackError","using","connection","arrayFormatString","array","Number","isInteger","buildWhere","where","clause","key","keys","Array","isArray","buildInsert","attributes","includeNames","names","placeholders","raw","buildUpdate","sets","insertStatement","table","pk","returning","join","insertStatements","arrayOfAttributes","arrayOfValues","insert","statement","all","toDatabase","column","type","toISOString","fromDatabase","Date"],"mappings":";;;;;;;;AAAA;;;;AAEA;;;;AACA;;AACA;;;;AACA;;;;;;;AAJA;;;AAMe,MAAMA,MAAN,4BAA8B;AAC3CC,cAAYC,OAAZ,EAAqB;AACnB,UAAMA,OAAN;;AAEA,SAAKC,MAAL,GAAcD,QAAQC,MAAtB;AACD;;AAEKC,OAAN,GAAc;AAAA;;AAAA;AACZ,UAAI,MAAKF,OAAL,CAAaG,GAAjB,EAAsB;AACpB,cAAM,MAAKC,OAAL,CAAa,yBAAb,CAAN;AACD;;AAED,UAAI,MAAKJ,OAAL,CAAaK,UAAjB,EAA6B;AAC3B,cAAM,MAAKD,OAAL,CAAa,gCAAb,CAAN;AACD;;AAED,UAAI,MAAKJ,OAAL,CAAaM,WAAjB,EAA8B;AAC5B,cAAM,MAAKF,OAAL,CAAa,wBAAwB,MAAKJ,OAAL,CAAaM,WAAb,CAAyBC,WAAzB,EAArC,CAAN;AACD;AAXW;AAYb;;AAEDC,QAAMC,KAAN,EAAa;AACX,WAAO,mBAAIA,KAAJ,EAAW,GAAX,CAAP;AACD;;AAED,SAAaC,OAAb,CAAqBC,EAArB,EAAyB;AAAA;AACvB,aAAO,MAAM,2BAAiBD,OAAjB,CAAyBC,EAAzB,CAAb;AADuB;AAExB;;AAED,SAAOC,QAAP,GAAkB;AAChB,+BAAiBA,QAAjB;AACD;;AAED,MAAIC,OAAJ,GAAc;AACZ,WAAO,QAAP;AACD;;AAEKC,OAAN,CAAYC,GAAZ,EAAiBC,MAAjB,EAAyBC,QAAzB,EAAmC;AAAA;;AAAA;AACjC,aAAKC,GAAL,CAASH,GAAT;;AAEA,UAAII,QAAQ,KAAZ;AACA,UAAIlB,SAAS,OAAKA,MAAlB;AACA,UAAImB,SAAS,IAAb;;AAEA,UAAInB,UAAU,IAAd,EAAoB;AAClBkB,gBAAQ,IAAR;AACAlB,iBAAS,MAAMH,OAAOY,OAAP,CAAe,OAAKV,OAAL,CAAaW,EAA5B,CAAf;AACD;;AAED,UAAIU,QAAQ,CAAZ;;AAEA,UAAI;AACFC,gBAAQJ,GAAR,CAAY,KAAZ,EAAmBH,GAAnB;AACAK,iBAASnB,OAAOsB,KAAP,CAAaR,GAAb,CAAT;;AAEA,eAAOK,OAAOI,OAAd,EAAuB;AACrB,gBAAMC,SAAS,MAAML,OAAOM,IAAP,EAArB;;AAEA,cAAID,UAAUR,QAAd,EAAwB;AACtB;AACA,kBAAMA,SAAS,EAACU,SAASF,OAAOE,OAAjB,EAA0BC,QAAQH,OAAOG,MAAzC,EAAiDP,OAAOI,OAAOJ,KAA/D,EAAsED,cAAtE,EAAT,CAAN;AACA;AACD;AACF;AACF,OAbD,CAaE,OAAOS,EAAP,EAAW;AACX,YAAI,OAAKC,OAAT,EAAkB;AAChBR,kBAAQS,KAAR,CAAc,OAAd,EAAuBF,EAAvB;AACD;;AAED,cAAMA,EAAN;AACD,OAnBD,SAmBU;AACR,eAAKG,aAAL,GAAqB/B,OAAOgC,SAAP,CAAiBC,YAAtC;;AAEA,YAAId,MAAJ,EAAY;AACV,cAAI;AACF,kBAAMA,OAAOD,KAAP,EAAN;AACD,WAFD,CAEE,OAAOgB,GAAP,EAAY;AACZ;AACA;AACA;AACD;AACF;;AAED,YAAIhB,KAAJ,EAAW;AACT,gBAAMlB,OAAOkB,KAAP,EAAN;AACD;AACF;AAjDgC;AAkDlC;;AAEKA,OAAN,GAAc;AAAA;;AAAA;AACZ,UAAI,OAAKlB,MAAT,EAAiB;AACf,cAAM,OAAKA,MAAL,CAAYkB,KAAZ,EAAN;;AAEA,eAAKlB,MAAL,GAAc,IAAd;AACD;AALW;AAMb;;AAEKmC,UAAN,CAAerB,GAAf,EAAoBC,MAApB,EAA4B;AAAA;;AAAA;AAC1B,UAAIqB,gBAAgB,IAApB;AACA,YAAMC,OAAO,EAAb;;AAEA,YAAM,OAAKxB,KAAL,CAAWC,GAAX,EAAgB,EAAhB;AAAA,qCAAoB,kBAAoC;AAAA,cAA5BY,OAA4B,SAA5BA,OAA4B;AAAA,cAAnBC,MAAmB,SAAnBA,MAAmB;AAAA,cAAXP,KAAW,SAAXA,KAAW;;AAC5D,cAAIgB,iBAAiB,IAArB,EAA2B;AACzBA,4BAAgBV,OAAhB;AACD;;AAED,cAAIC,MAAJ,EAAY;AACVU,iBAAKC,IAAL,CAAUX,MAAV;AACD;AACF,SARK;;AAAA;AAAA;AAAA;AAAA,WAAN;;AAUA,aAAO,EAAEU,MAAMA,IAAR,EAAcX,SAASU,aAAvB,EAAP;AAd0B;AAe3B;;AAEKd,OAAN,CAAYR,GAAZ,EAAiBC,MAAjB,EAAyB;AAAA;;AAAA;AACvB,aAAKE,GAAL,CAASH,GAAT;;AAEA,UAAId,SAAS,OAAKA,MAAlB;;AAEA,UAAIA,UAAU,IAAd,EAAoB;AAClBA,iBAAS,MAAMH,OAAOY,OAAP,CAAe,OAAKV,OAAL,CAAaW,EAA5B,CAAf;AACD;;AAED,aAAOV,OAAOsB,KAAP,CAAaR,GAAb,EAAkBC,MAAlB,CAAP;AATuB;AAUxB;;AAEDwB,qBAAmB;AACjB,QAAI,KAAKvC,MAAL,IAAe,IAAnB,EAAyB;AACvB,YAAM,IAAIwC,KAAJ,CAAU,6CAAV,CAAN;AACD;;AAED,WAAO,KAAKrC,OAAL,CAAa,oBAAb,CAAP;AACD;;AAEDsC,WAAS;AACP,QAAI,KAAKzC,MAAL,IAAe,IAAnB,EAAyB;AACvB,YAAM,IAAIwC,KAAJ,CAAU,8CAAV,CAAN;AACD;;AAED,WAAO,KAAKrC,OAAL,CAAa,qBAAb,CAAP;AACD;;AAEDuC,aAAW;AACT,QAAI,KAAK1C,MAAL,IAAe,IAAnB,EAAyB;AACvB,YAAM,IAAIwC,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,WAAO,KAAKrC,OAAL,CAAa,uBAAb,CAAP;AACD;;AAEKwC,aAAN,CAAkBC,KAAlB,EAAyB;AAAA;;AAAA;AACvB;AACA;AACA,YAAM5C,SAAS,MAAMH,OAAOY,OAAP,CAAe,OAAKV,OAAL,CAAaW,EAA5B,CAArB;;AAEA,YAAMA,KAAK,IAAIb,MAAJ,CAAWgD,OAAOC,MAAP,CAAc,EAAd,EAAkB,OAAK/C,OAAvB,EAAgC,EAACC,QAAQA,MAAT,EAAhC,CAAX,CAAX;;AAEA,YAAMU,GAAG6B,gBAAH,EAAN;;AAEA,UAAI;AACF,cAAMK,MAAMlC,EAAN,CAAN;AACA,cAAMA,GAAG+B,MAAH,EAAN;AACD,OAHD,CAGE,OAAOb,EAAP,EAAW;AACX,YAAI;AACF,gBAAMlB,GAAGgC,QAAH,EAAN;AACD,SAFD,CAEE,OAAOK,aAAP,EAAsB;AACtB,gBAAMrC,GAAGQ,KAAH,EAAN;AACA,gBAAM6B,aAAN;AACD;;AAED,cAAMnB,EAAN;AACD,OAZD,SAYU;AACR,cAAMlB,GAAGQ,KAAH,EAAN;AACD;AAvBsB;AAwBxB;;AAED,SAAOyB,WAAP,CAAmB5C,OAAnB,EAA4B6C,KAA5B,EAAmC;AACjC,QAAI7C,mBAAmBF,MAAvB,EAA+B;AAC7B,aAAOE,QAAQ4C,WAAR,CAAoBC,KAApB,CAAP;AACD;;AAED,WAAO,IAAI/C,MAAJ,CAAWE,OAAX,EAAoB4C,WAApB,CAAgCC,KAAhC,CAAP;AACD;;AAED,SAAaI,KAAb,CAAmBjD,OAAnB,EAA4B6C,KAA5B,EAAmC;AAAA;AACjC,YAAMK,aAAa,MAAMpD,OAAOY,OAAP,CAAeV,QAAQW,EAAvB,CAAzB;;AAEA,YAAMA,KAAK,IAAIb,MAAJ,CAAWgD,OAAOC,MAAP,CAAc,EAAd,EAAkB/C,OAAlB,EAA2B,EAACC,QAAQiD,UAAT,EAA3B,CAAX,CAAX;;AAEA,UAAI;AACF,cAAML,MAAMlC,EAAN,CAAN;AACD,OAFD,SAEU;AACR,cAAMuC,WAAW/B,KAAX,EAAN;AACD;AATgC;AAUlC;;AAEDgC,oBAAkBC,KAAlB,EAAyB;AACvB,QAAIC,OAAOC,SAAP,CAAiBF,MAAM,CAAN,CAAjB,CAAJ,EAAgC;AAC9B,aAAO,qBAAP;AACD,KAFD,MAEO,IAAI,OAAOA,MAAM,CAAN,CAAP,KAAoB,QAAxB,EAAkC;AACvC,aAAO,+BAAP;AACD;;AAED,WAAO,WAAP;AACD;;AAEDG,aAAWC,KAAX,EAAkB;AAChB,UAAMC,SAAS,EAAf;;AAEA,QAAID,KAAJ,EAAW;AACT,WAAK,MAAME,GAAX,IAAkBZ,OAAOa,IAAP,CAAYH,KAAZ,CAAlB,EAAsC;AACpC,YAAII,MAAMC,OAAN,CAAcL,MAAME,GAAN,CAAd,CAAJ,EAA+B;AAC7BD,iBAAOlB,IAAP,CAAY,wBAAS,eAAe,KAAKY,iBAAL,CAAuBK,MAAME,GAAN,CAAvB,CAAf,GAAoD,GAA7D,EAAkEA,GAAlE,EAAuEF,MAAME,GAAN,CAAvE,CAAZ;AACD,SAFD,MAEO;AACLD,iBAAOlB,IAAP,CAAY,wBAAS,SAAT,EAAoBmB,GAApB,EAAyBF,MAAME,GAAN,CAAzB,CAAZ;AACD;AACF;AACF;;AAED,WAAO,CAAED,MAAF,EAAU,EAAV,CAAP;AACD;;AAEDK,cAAYC,UAAZ,EAA6C;AAAA,QAArBC,YAAqB,uEAAN,IAAM;;AAC3C,UAAMC,QAAQ,EAAd;AACA,UAAMrC,SAAS,EAAf;AACA,UAAMsC,eAAe,EAArB;;AAEA;AACA;AACA;AACA;AACA,SAAK,MAAMR,GAAX,IAAkBZ,OAAOa,IAAP,CAAYI,UAAZ,CAAlB,EAA2C;AACzC,UAAIC,YAAJ,EAAkB;AAChBC,cAAM1B,IAAN,CAAW,wBAAS,IAAT,EAAemB,GAAf,CAAX;AACD;;AAED,YAAMjD,QAAQsD,WAAWL,GAAX,CAAd;;AAEA,UAAIE,MAAMC,OAAN,CAAcpD,KAAd,CAAJ,EAA0B;AACxByD,qBAAa3B,IAAb,CAAkB,wBAAS,WAAT,EAAsB9B,KAAtB,CAAlB;AACD,OAFD,MAEO,IAAIA,SAASA,MAAM0D,GAAnB,EAAwB;AAC7BD,qBAAa3B,IAAb,CAAkB,wBAAS,IAAT,EAAe9B,MAAM0D,GAArB,CAAlB;AACD,OAFM,MAEA;AACLD,qBAAa3B,IAAb,CAAkB,wBAAS,IAAT,EAAe9B,KAAf,CAAlB;AACD;AACF;;AAED,WAAO,CAAEwD,KAAF,EAASC,YAAT,EAAuBtC,MAAvB,CAAP;AACD;;AAEDwC,cAAYL,UAAZ,EAAwB;AACtB,UAAMM,OAAO,EAAb;AACA,UAAMzC,SAAS,EAAf;;AAEA,SAAK,MAAM8B,GAAX,IAAkBZ,OAAOa,IAAP,CAAYI,UAAZ,CAAlB,EAA2C;AACzC,YAAMtD,QAAQsD,WAAWL,GAAX,CAAd;;AAEA,UAAIE,MAAMC,OAAN,CAAcpD,KAAd,CAAJ,EAA0B;AACxB4D,aAAK9B,IAAL,CAAU,wBAAS,gBAAT,EAA2BmB,GAA3B,EAAgCjD,KAAhC,CAAV;AACD,OAFD,MAEO,IAAIA,SAASA,MAAM0D,GAAnB,EAAwB;AAC7BE,aAAK9B,IAAL,CAAU,wBAAS,SAAT,EAAoB9B,MAAM0D,GAA1B,CAAV;AACD,OAFM,MAEA;AACLE,aAAK9B,IAAL,CAAU,wBAAS,SAAT,EAAoBmB,GAApB,EAAyBjD,KAAzB,CAAV;AACD;AACF;;AAED,WAAO,CAAE4D,IAAF,EAAQzC,MAAR,CAAP;AACD;;AAED0C,kBAAgBC,KAAhB,EAAuBR,UAAvB,EAAmC/D,OAAnC,EAA4C;AAC1C,QAAIA,WAAW,IAAX,IAAmBA,QAAQwE,EAAR,IAAc,IAArC,EAA2C;AACzC,YAAM,IAAI/B,KAAJ,CAAU,gBAAV,CAAN;AACD;;AAHyC,uBAKF,KAAKqB,WAAL,CAAiBC,UAAjB,CALE;AAAA;;AAAA,UAKlCE,KALkC;AAAA,UAK3BC,YAL2B;AAAA,UAKbtC,MALa;;;AAO1C,UAAM6C,YAAY,EAAlB;;AAEA,UAAM1D,MAAM,kBAAO,qCAAP,EACOwD,KADP,EAEON,MAAMS,IAAN,CAAW,IAAX,CAFP,EAGOR,aAAaQ,IAAb,CAAkB,IAAlB,CAHP,EAIOD,SAJP,CAAZ;;AAMA,WAAO,EAAC1D,QAAD,EAAMa,cAAN,EAAP;AACD;;AAED+C,mBAAiBJ,KAAjB,EAAwBK,iBAAxB,EAA2C5E,OAA3C,EAAoD;AAClD,UAAM6E,gBAAgB,EAAtB;;AAEA,QAAIZ,QAAQ,IAAZ;;AAEA,SAAK,MAAMF,UAAX,IAAyBa,iBAAzB,EAA4C;AAC1C,YAAME,SAAS,KAAKhB,WAAL,CAAiBC,UAAjB,EAA6BE,SAAS,IAAtC,CAAf;;AAEA,UAAIA,SAAS,IAAb,EAAmB;AACjBA,gBAAQa,OAAO,CAAP,CAAR;AACD;;AAEDD,oBAActC,IAAd,CAAmB,MAAMuC,OAAO,CAAP,EAAUJ,IAAV,CAAe,IAAf,CAAN,GAA6B,GAAhD;AACD;;AAED,UAAM3D,MAAM,kBAAO,iCAAP,EACOwD,KADP,EAEON,MAAMS,IAAN,CAAW,IAAX,CAFP,EAGOG,cAAcH,IAAd,CAAmB,KAAnB,CAHP,CAAZ;;AAKA,WAAO,EAAC3D,QAAD,EAAMa,QAAQ,EAAd,EAAP;AACD;;AAEKkD,QAAN,CAAaP,KAAb,EAAoBR,UAApB,EAAgC/D,OAAhC,EAAyC;AAAA;;AAAA;AACvC,YAAM+E,YAAY,OAAKT,eAAL,CAAqBC,KAArB,EAA4BR,UAA5B,EAAwC/D,OAAxC,CAAlB;;AAEA,YAAMyB,SAAS,MAAM,OAAKuD,GAAL,CAASD,UAAUhE,GAAnB,EAAwBgE,UAAUnD,MAAlC,CAArB;;AAEA;AACA,aAAO,OAAKI,aAAZ;AACA;AAPuC;AAQxC;;AAEDiD,aAAWxE,KAAX,EAAkByE,MAAlB,EAA0B;AACxB,QAAIzE,SAAS,IAAb,EAAmB;AACjB,aAAO,IAAP;AACD;;AAED,YAAQyE,OAAOC,IAAf;AACE,WAAK,UAAL;AACE,eAAO1E,MAAM2E,WAAN,EAAP;;AAEF;AACE,eAAO,MAAMH,UAAN,CAAiBxE,KAAjB,EAAwByE,MAAxB,CAAP;AALJ;AAOD;;AAEDG,eAAa5E,KAAb,EAAoByE,MAApB,EAA4B;AAC1B,QAAIzE,SAAS,IAAb,EAAmB;AACjB,aAAO,IAAP;AACD;;AAED,YAAQyE,OAAOC,IAAf;AACE,WAAK,UAAL;AACE,eAAO,IAAIG,IAAJ,CAAS7E,KAAT,CAAP;;AAEF;AACE,eAAO,MAAM4E,YAAN,CAAmB5E,KAAnB,EAA0ByE,MAA1B,CAAP;AALJ;AAOD;AA1V0C;kBAAxBpF,M","file":"sqlite.js","sourcesContent":["import SQLiteConnection from './sqlite-connection';\n// import { Client } from 'minisqlite';\nimport pgformat from 'pg-format';\nimport { format } from 'util';\nimport esc from './esc';\nimport Database from './database';\n\nexport default class SQLite extends Database {\n  constructor(options) {\n    super(options);\n\n    this.client = options.client;\n  }\n\n  async setup() {\n    if (this.options.wal) {\n      await this.execute('PRAGMA journal_mode=WAL');\n    }\n\n    if (this.options.autoVacuum) {\n      await this.execute('PRAGMA auto_vacuum=INCREMENTAL');\n    }\n\n    if (this.options.synchronous) {\n      await this.execute('PRAGMA synchronous=' + this.options.synchronous.toUpperCase());\n    }\n  }\n\n  ident(value) {\n    return esc(value, '\"');\n  }\n\n  static async connect(db) {\n    return await SQLiteConnection.connect(db);\n  }\n\n  static shutdown() {\n    SQLiteConnection.shutdown();\n  }\n\n  get dialect() {\n    return 'sqlite';\n  }\n\n  async _each(sql, params, callback) {\n    this.log(sql);\n\n    let close = false;\n    let client = this.client;\n    let cursor = null;\n\n    if (client == null) {\n      close = true;\n      client = await SQLite.connect(this.options.db);\n    }\n\n    let index = 0;\n\n    try {\n      console.log('RUN', sql);\n      cursor = client.query(sql);\n\n      while (cursor.hasRows) {\n        const result = await cursor.next();\n\n        if (result && callback) {\n          /* eslint-disable callback-return */\n          await callback({columns: result.columns, values: result.values, index: result.index, cursor});\n          /* eslint-enable callback-return */\n        }\n      }\n    } catch (ex) {\n      if (this.verbose) {\n        console.error('ERROR', ex);\n      }\n\n      throw ex;\n    } finally {\n      this._lastInsertID = client.rawClient.lastInsertID;\n\n      if (cursor) {\n        try {\n          await cursor.close();\n        } catch (err) {\n          // Closing the cursor on a connection where there was a previous error rethrows the same error\n          // This is because pumping the cursor to completion ends up carrying the original error to\n          // the end. This is desired behavior, we just have to swallow any potential errors here.\n        }\n      }\n\n      if (close) {\n        await client.close();\n      }\n    }\n  }\n\n  async close() {\n    if (this.client) {\n      await this.client.close();\n\n      this.client = null;\n    }\n  }\n\n  async _execute(sql, params) {\n    let resultColumns = null;\n    const rows = [];\n\n    await this._each(sql, [], async ({columns, values, index}) => {\n      if (resultColumns == null) {\n        resultColumns = columns;\n      }\n\n      if (values) {\n        rows.push(values);\n      }\n    });\n\n    return { rows: rows, columns: resultColumns };\n  }\n\n  async query(sql, params) {\n    this.log(sql);\n\n    let client = this.client;\n\n    if (client == null) {\n      client = await SQLite.connect(this.options.db);\n    }\n\n    return client.query(sql, params);\n  }\n\n  beginTransaction() {\n    if (this.client == null) {\n      throw new Error('client is null when beginning a transaction');\n    }\n\n    return this.execute('BEGIN TRANSACTION;');\n  }\n\n  commit() {\n    if (this.client == null) {\n      throw new Error('client is null when committing a transaction');\n    }\n\n    return this.execute('COMMIT TRANSACTION;');\n  }\n\n  rollback() {\n    if (this.client == null) {\n      throw new Error('client is null when rolling back a transaction');\n    }\n\n    return this.execute('ROLLBACK TRANSACTION;');\n  }\n\n  async transaction(block) {\n    // get a connection from the pool and make sure it gets used throughout the\n    // transaction block.\n    const client = await SQLite.connect(this.options.db);\n\n    const db = new SQLite(Object.assign({}, this.options, {client: client}));\n\n    await db.beginTransaction();\n\n    try {\n      await block(db);\n      await db.commit();\n    } catch (ex) {\n      try {\n        await db.rollback();\n      } catch (rollbackError) {\n        await db.close();\n        throw rollbackError;\n      }\n\n      throw ex;\n    } finally {\n      await db.close();\n    }\n  }\n\n  static transaction(options, block) {\n    if (options instanceof SQLite) {\n      return options.transaction(block);\n    }\n\n    return new SQLite(options).transaction(block);\n  }\n\n  static async using(options, block) {\n    const connection = await SQLite.connect(options.db);\n\n    const db = new SQLite(Object.assign({}, options, {client: connection}));\n\n    try {\n      await block(db);\n    } finally {\n      await connection.close();\n    }\n  }\n\n  arrayFormatString(array) {\n    if (Number.isInteger(array[0])) {\n      return 'ARRAY[%L]::bigint[]';\n    } else if (typeof array[0] === 'number') {\n      return 'ARRAY[%L]::double precision[]';\n    }\n\n    return 'ARRAY[%L]';\n  }\n\n  buildWhere(where) {\n    const clause = [];\n\n    if (where) {\n      for (const key of Object.keys(where)) {\n        if (Array.isArray(where[key])) {\n          clause.push(pgformat('%I = ANY (' + this.arrayFormatString(where[key]) + ')', key, where[key]));\n        } else {\n          clause.push(pgformat('%I = %L', key, where[key]));\n        }\n      }\n    }\n\n    return [ clause, [] ];\n  }\n\n  buildInsert(attributes, includeNames = true) {\n    const names = [];\n    const values = [];\n    const placeholders = [];\n\n    // Use the literal values instead of placeholders  because parameterized\n    // queries require prepared statements. Prepared statements are stateful\n    // and impose requirements on the connection that are incompatible with\n    // pgbouncer.\n    for (const key of Object.keys(attributes)) {\n      if (includeNames) {\n        names.push(pgformat('%I', key));\n      }\n\n      const value = attributes[key];\n\n      if (Array.isArray(value)) {\n        placeholders.push(pgformat('ARRAY[%L]', value));\n      } else if (value && value.raw) {\n        placeholders.push(pgformat('%s', value.raw));\n      } else {\n        placeholders.push(pgformat('%L', value));\n      }\n    }\n\n    return [ names, placeholders, values ];\n  }\n\n  buildUpdate(attributes) {\n    const sets = [];\n    const values = [];\n\n    for (const key of Object.keys(attributes)) {\n      const value = attributes[key];\n\n      if (Array.isArray(value)) {\n        sets.push(pgformat('%I = ARRAY[%L]', key, value));\n      } else if (value && value.raw) {\n        sets.push(pgformat('%I = %s', value.raw));\n      } else {\n        sets.push(pgformat('%I = %L', key, value));\n      }\n    }\n\n    return [ sets, values ];\n  }\n\n  insertStatement(table, attributes, options) {\n    if (options == null || options.pk == null) {\n      throw new Error('pk is required');\n    }\n\n    const [ names, placeholders, values ] = this.buildInsert(attributes);\n\n    const returning = '';\n\n    const sql = format('INSERT INTO %s (%s)\\nVALUES (%s)%s;',\n                       table,\n                       names.join(', '),\n                       placeholders.join(', '),\n                       returning);\n\n    return {sql, values};\n  }\n\n  insertStatements(table, arrayOfAttributes, options) {\n    const arrayOfValues = [];\n\n    let names = null;\n\n    for (const attributes of arrayOfAttributes) {\n      const insert = this.buildInsert(attributes, names == null);\n\n      if (names == null) {\n        names = insert[0];\n      }\n\n      arrayOfValues.push('(' + insert[1].join(', ') + ')');\n    }\n\n    const sql = format('INSERT INTO %s (%s)\\nVALUES %s;',\n                       table,\n                       names.join(', '),\n                       arrayOfValues.join(',\\n'));\n\n    return {sql, values: {}};\n  }\n\n  async insert(table, attributes, options) {\n    const statement = this.insertStatement(table, attributes, options);\n\n    const result = await this.all(statement.sql, statement.values);\n\n    // TODO(zhm) broken\n    return this._lastInsertID;\n    // return +result[0].id;\n  }\n\n  toDatabase(value, column) {\n    if (value == null) {\n      return null;\n    }\n\n    switch (column.type) {\n      case 'datetime':\n        return value.toISOString();\n\n      default:\n        return super.toDatabase(value, column);\n    }\n  }\n\n  fromDatabase(value, column) {\n    if (value == null) {\n      return null;\n    }\n\n    switch (column.type) {\n      case 'datetime':\n        return new Date(value);\n\n      default:\n        return super.fromDatabase(value, column);\n    }\n  }\n}\n\n"]}