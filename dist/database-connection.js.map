{"version":3,"sources":["../src/database-connection.js"],"names":["POOLS","DatabaseConnection","constructor","pool","rawClient","connectionString","connect","query","close","release","_connect","ConnectionClass","Promise","resolve","reject","acquire","err","client","_pool","createPool","params","db","max","idleTimeoutMillis","reapIntervalMillis","shutdown","connection","Object","keys","drain","destroyAllNow"],"mappings":";;;;;;;;AAAA;AACA;;AAEA,MAAMA,QAAQ,EAAd;;AAEA;AACA;AACA;AACA;AACe,MAAMC,kBAAN,CAAyB;AACtCC,cAAYC,IAAZ,EAAkBC,SAAlB,EAA6B;AAC3B,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACD;;AAED,SAAOD,IAAP,CAAYE,gBAAZ,EAA8B;AAC5B;AACD;;AAED,SAAaC,OAAb,CAAqBD,gBAArB,EAAuC;AACrC;;AADqC;AAEtC;;AAEDE,UAAe;AACb;AACD;;AAEDC,UAAQ;AACN,SAAKL,IAAL,CAAUM,OAAV,CAAkB,KAAKL,SAAvB;AACA,SAAKA,SAAL,GAAiB,IAAjB;AACD;;AAED,SAAaM,QAAb,CAAsBC,eAAtB,EAAuCN,gBAAvC,EAAyD;AAAA;AACvD,aAAO,IAAIO,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,cAAMX,OAAOQ,gBAAgBR,IAAhB,CAAqBE,gBAArB,CAAb;;AAEAF,aAAKY,OAAL,CAAa,UAACC,GAAD,EAAMC,MAAN,EAAiB;AAC5B,cAAID,GAAJ,EAAS;AACP,mBAAOF,OAAOE,GAAP,CAAP;AACD;;AAED,iBAAOH,QAAQ,IAAIF,eAAJ,CAAoBR,IAApB,EAA0Bc,MAA1B,CAAR,CAAP;AACD,SAND;AAOD,OAVM,CAAP;AADuD;AAYxD;;AAED,SAAOC,KAAP,CAAaC,UAAb,EAAyBd,gBAAzB,EAA2C;AACzC,QAAIF,OAAOH,MAAMK,gBAAN,CAAX;;AAEA,QAAIF,QAAQ,IAAZ,EAAkB;AAChB,YAAMiB,SAAS;AACbC,YAAIhB,gBADS;AAEbiB,aAAK,EAFQ;AAGbC,2BAAmBtB,mBAAmBsB,iBAHzB;AAIbC,4BAAoBvB,mBAAmBuB;AAJ1B,OAAf;;AAOArB,aAAOH,MAAMK,gBAAN,IAA0Bc,WAAWC,MAAX,CAAjC;AACD;;AAED,WAAOjB,IAAP;AACD;;AAED,SAAOsB,QAAP,GAAkB;AAChB,SAAK,MAAMC,UAAX,IAAyBC,OAAOC,IAAP,CAAY5B,KAAZ,CAAzB,EAA6C;AAC3C,YAAMG,OAAOH,MAAM0B,UAAN,CAAb;;AAEA,UAAIvB,IAAJ,EAAU;AACRA,aAAK0B,KAAL,CAAW,MAAM;AACf1B,eAAK2B,aAAL;AACD,SAFD;AAGD;AACF;AACF;AAhEqC;;kBAAnB7B,kB;AAmErBA,mBAAmBsB,iBAAnB,GAAuC,IAAvC;AACAtB,mBAAmBuB,kBAAnB,GAAwC,IAAxC","file":"database-connection.js","sourcesContent":["// import { createPool } from 'minipg';\n// import PostgresCursor from './postgres-cursor';\n\nconst POOLS = {};\n\n// Wrap a single connection w/ a query method in an async function.\n// This is used when we need to execute multiple successive queries and make sure\n// they're executed on the *same* connection and not separate connections\n// from the connection pool.\nexport default class DatabaseConnection {\n  constructor(pool, rawClient) {\n    this.pool = pool;\n    this.rawClient = rawClient;\n  }\n\n  static pool(connectionString) {\n    // implement\n  }\n\n  static async connect(connectionString) {\n    // implement\n  }\n\n  query(...args) {\n    // return new PostgresCursor(this, this.rawClient.query(...args));\n  }\n\n  close() {\n    this.pool.release(this.rawClient);\n    this.rawClient = null;\n  }\n\n  static async _connect(ConnectionClass, connectionString) {\n    return new Promise((resolve, reject) => {\n      const pool = ConnectionClass.pool(connectionString);\n\n      pool.acquire((err, client) => {\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(new ConnectionClass(pool, client));\n      });\n    });\n  }\n\n  static _pool(createPool, connectionString) {\n    let pool = POOLS[connectionString];\n\n    if (pool == null) {\n      const params = {\n        db: connectionString,\n        max: 25,\n        idleTimeoutMillis: DatabaseConnection.idleTimeoutMillis,\n        reapIntervalMillis: DatabaseConnection.reapIntervalMillis\n      };\n\n      pool = POOLS[connectionString] = createPool(params);\n    }\n\n    return pool;\n  }\n\n  static shutdown() {\n    for (const connection of Object.keys(POOLS)) {\n      const pool = POOLS[connection];\n\n      if (pool) {\n        pool.drain(() => {\n          pool.destroyAllNow();\n        });\n      }\n    }\n  }\n}\n\nDatabaseConnection.idleTimeoutMillis = null;\nDatabaseConnection.reapIntervalMillis = null;\n"]}